const fs = require('fs-extra');
const path = require('path');
const moment = require('moment');
const { GoogleGenAI } = require('@google/genai');

// Load local environment variables for development
if (fs.existsSync('.env.local')) {
  require('dotenv').config({ path: '.env.local' });
}

// Build script to generate static website from JSON data
class NewsArchiveBuilder {
  constructor(options = {}) {
    this.assetsDir = './assets';
    this.outputDir = './dist';
    this.analysisDir = './analysis';
    this.templateDir = './templates';
    this.forceApiMode = options.forceApi || false;
    this.daysLimit = options.daysLimit || null; // Global variable to control days limit (null = no limit, number = limit to X days)
    this.genAI = new GoogleGenAI({ apiKey: process.env.GEMINI_API_KEY || 'your-api-key-here' });
  }

  // Extract summary from content field (text after first colon, strip HTML)
  extractSummaryFromContent(content, maxLength = 200) {
    if (!content) return '';
    
    // Remove HTML tags
    const textContent = content.replace(/<[^>]*>/g, '');
    
    // Find the first colon and take everything after it
    const colonIndex = textContent.indexOf('Ôºö');
    if (colonIndex !== -1) {
      return textContent.substring(colonIndex + 1).trim();
    }
    
    // Fallback: if no Chinese colon, try regular colon
    const regularColonIndex = textContent.indexOf(':');
    if (regularColonIndex !== -1) {
      return textContent.substring(regularColonIndex + 1).trim();
    }
    
    // If no colon found, return the whole text
    return textContent.trim();
  }

  // Truncate text and add read more link
  truncateSummary(text, maxLength = 100) {
    if (!text) return '';
    
    if (text.length <= maxLength) {
      return text;
    }
    
    const truncated = text.substring(0, maxLength).trim();
    return truncated;
  }

  // Clean title by removing bracketed prefixes like [ËßÜÈ¢ë]
  cleanTitle(title) {
    if (!title) return '';
    return title.replace(/^\[[^\]]*\]\s*/, '');
  }

  async build() {
    console.log('üèóÔ∏è  Building CCTV News Archive...');
    
    // Clean and create output directory
    await fs.remove(this.outputDir);
    await fs.ensureDir(this.outputDir);
    await fs.ensureDir(this.analysisDir);
    
    // Copy static assets
    await this.copyStaticAssets();
    
    // Generate data index
    const newsIndex = await this.generateNewsIndex();
    
    // Generate HTML pages
    await this.generateHomePage(newsIndex);
    await this.generateArchivePages(newsIndex);
    await this.generateAPIEndpoints(newsIndex);
    
    console.log('‚úÖ Build completed successfully!');
  }

  async copyStaticAssets() {
    console.log('üìÇ Copying static assets...');
    
    // Copy CSS, JS, images
    const staticDirs = ['css', 'js', 'images'];
    for (const dir of staticDirs) {
      const srcDir = path.join('./static', dir);
      const destDir = path.join(this.outputDir, dir);
      
      if (await fs.pathExists(srcDir)) {
        await fs.copy(srcDir, destDir);
      }
    }
  }

  async generateNewsIndex() {
    console.log('üìä Generating news index...');
    
    const index = {
      totalNews: 0,
      dateRange: { start: null, end: null },
      years: {},
      categories: {},
      recentNews: []
    };

    // Scan all years
    const years = await fs.readdir(this.assetsDir);
    
    for (const year of years) {
      const yearPath = path.join(this.assetsDir, year);
      if (!(await fs.stat(yearPath)).isDirectory()) continue;
      
      index.years[year] = { months: {}, totalNews: 0 };
      
      const files = await fs.readdir(yearPath);
      const jsonFiles = files.filter(f => f.endsWith('.json')).sort();
      
      for (const file of jsonFiles) {
        const filePath = path.join(yearPath, file);
        const date = file.replace('.json', '');
        
        try {
          const data = await fs.readJson(filePath);
          const newsCount = data.videoList ? data.videoList.length : 0;
          
          index.totalNews += newsCount;
          index.years[year].totalNews += newsCount;
          
          // Update date range
          if (!index.dateRange.start || date < index.dateRange.start) {
            index.dateRange.start = date;
          }
          if (!index.dateRange.end || date > index.dateRange.end) {
            index.dateRange.end = date;
          }
          
          // Group by month
          const month = date.substring(4, 6);
          if (!index.years[year].months[month]) {
            index.years[year].months[month] = [];
          }
          index.years[year].months[month].push({
            date,
            newsCount,
            file: `${year}/${file}`
          });
          
          // Collect categories
          if (data.videoList) {
            data.videoList.forEach(video => {
              if (video.news_hl_tag) {
                // Split by common delimiters and clean up
                const categories = video.news_hl_tag.split(/[,\s]+/).filter(cat => cat.trim());
                categories.forEach(cat => {
                  const cleanCat = cat.trim();
                  if (cleanCat && cleanCat !== 'General') {
                    index.categories[cleanCat] = (index.categories[cleanCat] || 0) + 1;
                  }
                });
              }
            });
          }
          
          // Add to recent news (last 30 days)
          const daysDiff = moment().diff(moment(date, 'YYYYMMDD'), 'days');
          if (daysDiff <= 30 && data.videoList) {
            index.recentNews.push(...data.videoList.map(video => ({
              ...video,
              date,
              year
            })));
          }
          
        } catch (error) {
          console.warn(`‚ö†Ô∏è  Error reading ${filePath}:`, error.message);
        }
      }
    }
    
    // Sort recent news by date
    index.recentNews.sort((a, b) => b.date.localeCompare(a.date));
    index.recentNews = index.recentNews.slice(0, 100); // Keep latest 100
    
    return index;
  }

  // Generate AI-powered daily investment analysis using Gemini
  async generateDailySummary() {
    // Get Beijing time (UTC+8) to match repository timezone
    const getBeijingTime = () => {
      return moment().utcOffset('+08:00');
    };
    
    const today = getBeijingTime().format('YYYYMMDD');
    const todayFile = path.join(this.assetsDir, '2025', `${today}.json`);
    const analysisFile = path.join(this.analysisDir, `${today}.json`);
    
    // Step 1: Check if today's news JSON exists and is not empty FIRST
    let newsItems = [];
    let targetDate = today;
    let fallbackDate = null;
    
    try {
      const data = await fs.readJson(todayFile);
      newsItems = data.videoList || [];
      if (newsItems.length > 0) {
        console.log(`ü§ñ Generating AI analysis for ${today} (${newsItems.length} news items)`);
      }
    } catch (error) {
      console.log(`‚ö†Ô∏è Today's news file not found or unreadable: ${today}.json`);
    }
    
    // Step 2: If today's news exists and is not empty, check if we need to regenerate analysis
    if (newsItems.length > 0) {
      if (!this.forceApiMode && await fs.pathExists(analysisFile)) {
        try {
          const savedAnalysis = await fs.readJson(analysisFile);
          if (savedAnalysis.total_news > 0 && savedAnalysis.has_data !== false && savedAnalysis.news_date === today) {
            console.log(`üìñ Using existing analysis for ${today} (${savedAnalysis.total_news} news items)`);
            return savedAnalysis;
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to read cached analysis, will regenerate:`, error.message);
        }
      }
      // Generate new analysis for today's news
      console.log(`ü§ñ Generating fresh AI analysis for ${today} (${newsItems.length} news items)`);
    } else {
      // Step 3: Today's news is empty, find the last available date with non-empty news JSON
      console.log(`‚ö†Ô∏è Today's news is empty, finding latest available news data...`);
      
      let checkDate = getBeijingTime().subtract(1, 'day');
      
      for (let i = 0; i < 7; i++) {
        const dateStr = checkDate.format('YYYYMMDD');
        const newsFile = path.join(this.assetsDir, checkDate.format('YYYY'), `${dateStr}.json`);
        
        try {
          if (await fs.pathExists(newsFile)) {
            const newsData = await fs.readJson(newsFile);
            const hasNews = newsData.videoList && newsData.videoList.length > 0;
            
            if (hasNews) {
              targetDate = dateStr;
              newsItems = newsData.videoList;
              console.log(`üìÖ Found latest news data from ${targetDate} (${newsItems.length} items)`);
              break;
            }
          }
        } catch (error) {
          // Continue checking other dates
        }
        
        checkDate.subtract(1, 'day');
      }
      
      if (newsItems.length === 0) {
        // No news data available at all, create empty analysis
        const emptyResult = {
          summary: {
            investment_quote: '‰ªäÊó•ÊöÇÊó†Êñ∞ÈóªÊï∞ÊçÆ',
            core_logic: '‰ªäÊó•ÊöÇÊó†Êñ∞ÈóªÊï∞ÊçÆÔºåÊó†Ê≥ïÁîüÊàêÊäïËµÑÂàÜÊûê'
          },
          total_news: 0,
          opportunity_analysis: [],
          has_data: false
        };
        const timestamp = getBeijingTime().format('YYYYMMDD_HHmmss');
        const analysisWithMeta = {
          ...emptyResult,
          generated_at: timestamp,
          news_date: today
        };
        await fs.writeJson(analysisFile, analysisWithMeta);
        console.log(`üíæ Saved empty analysis to ${analysisFile}`);
        return emptyResult;
      }
    }
    
    // Step 3: For fallback dates, check if analysis JSON exists and is not empty
    if (targetDate !== today) {
      const targetAnalysisFile = path.join(this.analysisDir, `${targetDate}.json`);
      if (!this.forceApiMode && await fs.pathExists(targetAnalysisFile)) {
        try {
          const targetAnalysis = await fs.readJson(targetAnalysisFile);
          if (targetAnalysis.total_news > 0 && targetAnalysis.has_data !== false) {
            console.log(`üìñ Using existing analysis from ${targetDate} for today`);
            // Return the target analysis but update metadata for today
            const todayAnalysis = {
              ...targetAnalysis,
              news_date: today,
              fallback_from: targetDate
            };
            return todayAnalysis;
          }
        } catch (error) {
          console.warn(`‚ö†Ô∏è Failed to read target analysis from ${targetDate}, will generate new:`, error.message);
        }
      }
      
      fallbackDate = targetDate;
      console.log(`ü§ñ Generating AI analysis using news data from ${targetDate} for today`);
    }

    // Generate AI analysis
    try {
      // Check if API key is available
      if (!process.env.GEMINI_API_KEY || process.env.GEMINI_API_KEY === 'your-api-key-here' || process.env.GEMINI_API_KEY === 'your_local_gemini_api_key_here') {
        console.log('‚ÑπÔ∏è  Gemini API key not configured, using fallback summary');
        const fallbackResult = this.generateFallbackSummary(newsItems);
        const timestamp = getBeijingTime().format('YYYYMMDD_HHmmss');
        const analysisWithMeta = {
          ...fallbackResult,
          generated_at: timestamp,
          news_date: fallbackDate || today
        };
        const actualAnalysisFile = path.join(this.analysisDir, `${fallbackDate || today}.json`);
        await fs.writeJson(actualAnalysisFile, analysisWithMeta);
        console.log(`üíæ Saved fallback analysis to ${actualAnalysisFile}`);
        return fallbackResult;
      }

      // Prepare news data for Gemini - include full content for all items
      const newsText = newsItems.map((news, index) => {
        const baseInfo = `${index + 1}. ${this.cleanTitle(news.video_title)}\n   ID: ${news.video_id}\n   ${news.brief || 'ÊöÇÊó†ÁÆÄ‰ªã'}\n   ÂàÜÁ±ª: ${news.news_hl_tag || 'Êú™ÂàÜÁ±ª'}`;
        
        if (news.video_detail?.content) {
          return `${baseInfo}\n   ÂÖ®ÊñáÂÜÖÂÆπ: ${news.video_detail.content}`;
        }
        return baseInfo;
      }).join('\n\n');

      const prompt = `‰Ω†ÊòØ‰∏ÄÂêç‰∏ìÊ≥®‰∫éÊîøÁ≠ñÈ©±Âä®ÊäïËµÑÁöÑÈ°∂Â∞ñÁ≠ñÁï•ÂàÜÊûêÂ∏àÔºåÊìÖÈïø‰ªéÊñ∞ÈóªËÅîÊí≠‰∏≠ËØÜÂà´ÁªìÊûÑÊÄßÊäïËµÑÊú∫‰ºö„ÄÇËØ∑Âü∫‰∫é‰ª•‰∏ã${newsItems.length}Êù°${fallbackDate ? `${fallbackDate}ÁöÑ` : '‰ªäÊó•'}Êñ∞ÈóªÔºå‰∏∫Êú∫ÊûÑÊäïËµÑËÄÖÊèê‰æõÂèØÁõ¥Êé•Á∫≥ÂÖ•ÊäïËµÑÂÜ≥Á≠ñÁöÑÊ∑±Â∫¶ÂàÜÊûê${fallbackDate ? `Ôºà‰ªäÊó•ÊöÇÊó†Êñ∞ÈóªÔºåÊ≠§ÂàÜÊûêÂü∫‰∫éÊúÄËøëÁöÑÊñ∞ÈóªÊï∞ÊçÆÔºâ` : ''}„ÄÇ

--- ${fallbackDate ? `${fallbackDate}Êñ∞Èóª` : '‰ªäÊó•Êñ∞Èóª'} ---
${newsText}
--- ÁªìÊùü ---

**Ê†∏ÂøÉ‰ªªÂä°ÔºöÂø´ÈÄüÊÄªÁªìÊØèÊó•Êñ∞ÈóªÔºåËØÜÂà´ÊúÄÁõ∏ÂÖ≥ÊäïËµÑÊú∫‰ºöÔºåËøõË°åÊ∑±Â∫¶ÂàÜÊûêÔºåÊèê‰æõÊäïËµÑËßíÂ∫¶ÂíåÂèØÊâßË°åÂª∫ËÆÆ**

ËØ∑‰∏•Ê†ºÊåâÁÖß‰ª•‰∏ãJSONÊ†ºÂºèËøîÂõûÂàÜÊûêÁªìÊûúÔºö

{
  "summary": {
    "investment_quote": "Ê†πÊçÆ‰ªäÊó•ÂÜÖÂÆπÔºå‰∏ÄÂè•Á≤æÁÇºÁöÑÊûÅÂÖ∑‰º†Êí≠‰ª∑ÂÄºÁöÑÊäïËµÑÈáëÂè•Ôºà30Â≠ó‰ª•ÂÜÖÔºåË¶ÅÊúâÊ¥ûÂØüÂäõÂíåËΩ¨Âèë‰ª∑ÂÄºÔºâ",
    "core_logic": "Áî®‰∏ÄÊÆµËØùÔºà100-150Â≠óÔºâÊ¶ÇÊã¨‰ªäÊó•Êñ∞ÈóªÂèçÂ∫îÁöÑÊúÄÊ†∏ÂøÉÁöÑÊäïËµÑÈÄªËæëÔºåË¶ÅÊúâÂÜ≤ÂáªÂäõÂíåËÆ∞ÂøÜÁÇπ"
  },
  "opportunity_analysis": [
    {
      "theme": "ÊîøÁ≠ñ‰∏ªÈ¢òÔºàÊåâÊñ∞ÈóªÁõ∏ÂÖ≥ÊÄßÁî±È´òÂà∞‰ΩéÊéíÂ∫èÔºåÊúÄÂ•ΩËÉΩÁîüÊàêÂÖ≠‰∏™Êàñ‰ª•‰∏äÔºå‰ΩÜ‰∏çË¶ÅÁºñÈÄ†‰∏éÊñ∞ÈóªÊó†ÂÖ≥ÁöÑ‰∏ªÈ¢òÔºâ",
      "impact": "ÊîøÁ≠ñÂØπÂ∏ÇÂú∫ÁöÑÂΩ±ÂìçÊèèËø∞ÔºåÂ¶ÇÊúâËµÑÈáëËßÑÊ®°ËØ∑Ê≥®Êòé",
      "actionable_advice": "‰∏ÄÂè•ËØùÂèôËø∞ÂÖ∑‰ΩìÁöÑÊäïËµÑËßíÂ∫¶ÔºåÂØπÂèØËÉΩÂèóÁõäÁöÑÁªÜÂàÜÈ¢ÜÂüüÊàñËÇ°Á•®Á±ªÂûãÁªôÂá∫ÊòéÁ°ÆÁöÑÂèØÊâßË°åÊäïËµÑÂª∫ËÆÆ",
      "core_stocks": ["string"], // 6-8Âè™Ê†∏ÂøÉËÇ°Á•®[ÂêçÁß∞(‰ª£Á†Å)]ÔºåÈÄâÁõ∏ÂÖ≥ÊÄßÊúÄÈ´òÔºåÊµÅÂä®ÊÄßÂ•ΩÁöÑÈæôÂ§¥
      "sector_etfs": ["string"], // 1-4Âè™Áõ∏ÂÖ≥ÊÄßÊúÄÈ´òÁöÑË°å‰∏öETF[ÂêçÁß∞(‰ª£Á†Å)]
      "related_news_ids": ["string"] // Áî®‰∫éÁîüÊàêËøô‰∏™ÊîøÁ≠ñ‰∏ªÈ¢òÁöÑÊñ∞Èóªvideo_idÔºålist the one most relevant ID
  ]
}

**ÊäïËµÑÂàÜÊûêÊ°ÜÊû∂Ë¶ÅÊ±ÇÔºö**

1. **ÊîøÁ≠ñÈ©±Âä®‰ºòÂÖà** - ÈáçÁÇπÂàÜÊûêÊúâÊòéÁ°ÆÊîøÁ≠ñËÉå‰π¶ÁöÑÊú∫‰ºö
2. **Êï∞ÊçÆÊîØÊíë** - ÊØè‰∏™Âà§Êñ≠Â∞ΩÈáèÂºïÁî®Êñ∞Èóª‰∏≠ÁöÑÂÖ∑‰ΩìÊï∞ÊçÆÔºàÈáëÈ¢ù„ÄÅÁôæÂàÜÊØî„ÄÅÊó∂Èó¥Á≠âÔºâ
3. **‰∫ß‰∏öÈìæÊÄùÁª¥** - ‰ªé‰∏äÊ∏∏Âà∞‰∏ãÊ∏∏ÂàÜÊûêÂèóÁõäÁéØËäÇ
4. **ÂèØÊìç‰ΩúÊÄß** - Êèê‰æõÂÖ∑‰ΩìËÇ°Á•®ÂíåETFÂª∫ËÆÆÔºå‰æø‰∫éÁ´ãÂç≥ÊâßË°å

**ÂÜÖÂÆπË¥®ÈáèË¶ÅÊ±ÇÔºö**

‚úÖ **ÂøÖÈ°ªÂÅöÂà∞**Ôºö
- ÊØè‰∏™Êú∫‰ºöÈÉΩË¶ÅÊèê‰æõËá≥Â∞ë5Âè™Áõ∏ÂÖ≥ËÇ°Á•®Âíå1Âè™ETFÔºå‰ΩÜ‰∏çË¶ÅËÉ°‰π±ÁºñÈÄ†
- ÊâÄÊúâÂÜÖÂÆπÂøÖÈ°ªÂü∫‰∫éÂΩìÊó•Êñ∞ÈóªËÅîÊí≠ÔºåÂ∞ΩÈáèÊèê‰æõÊñ∞Èóª‰∏≠ÂÖ∑‰ΩìÊï∞ÊçÆÂíåËßÑÊ®°ÁöÑÊîØÊåÅ
- ËÇ°Á•®ÈÄâÊã©ÊµÅÂä®ÊÄßÂ•ΩÁöÑË°å‰∏öÈæôÂ§¥ÔºåETFÈÄâÊã©Ë∑üË∏™Áõ∏ÂÖ≥Ë°å‰∏öÁöÑÂÆΩÂü∫ÊåáÊï∞
- Áî®ÊäïËµÑËÄÖÁÜüÊÇâÁöÑ‰∏ì‰∏öÊúØËØ≠‰ΩÜÈÅøÂÖçjargon
- ÂêåÁ±ªÈ°πÂÜÖÂÆπÈÅøÂÖçÈáçÂ§ç

‚ùå **‰∏•Ê†ºÈÅøÂÖç**Ôºö
- Ê≥õÊ≥õËÄåË∞àÁöÑË°å‰∏öÊé®ËçêÔºàÂ¶Ç"ÂÖ≥Ê≥®ÁßëÊäÄËÇ°"Ôºâ
- Ê≤°ÊúâÊï∞ÊçÆÊîØÊíëÁöÑ‰∏ªËßÇÂà§Êñ≠
- ‰∏éÊñ∞ÈóªÂÜÖÂÆπÊó†ÂÖ≥ÁöÑÂ∏∏ËßÑÂª∫ËÆÆ
- ‰ΩøÁî®Ëã±ÊñáÊúØËØ≠ÊàñÊ∑∑ÂêàË°®Ëææ

**ËæìÂá∫ËßÑËåÉÔºö**
- ÂÖ®ÈÉ®‰ΩøÁî®Á∫Ø‰∏≠ÊñáÔºå‰∏ì‰∏ö‰ΩÜÊòìÊáÇ
- ÊäïËµÑÂª∫ËÆÆË¶ÅÂèØÁ´ãÂç≥ÊâßË°å
- ‰øùÊåÅÂÆ¢ËßÇ‰∏≠Á´ãÔºå‰∏çÂ§∏Â§ßÊî∂Áõä

Áé∞Âú®ÔºåËØ∑Âü∫‰∫é‰ªäÊó•Êñ∞ÈóªËÅîÊí≠ÂÜÖÂÆπÔºåÊèê‰æõ‰∏ì‰∏öÁöÑË∂ãÂäøÊäïËµÑÂàÜÊûêÔºö`;

      const response = await this.genAI.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt
      });
      
      const text = response.candidates[0].content.parts[0].text;
      console.log('Gemini response text:', text);
      
      // Parse JSON response
      let analysis;
      try {
        // Clean the response text to extract JSON
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          analysis = JSON.parse(jsonMatch[0]);
        } else {
          throw new Error('No JSON found in response');
        }
      } catch (parseError) {
        console.warn('‚ö†Ô∏è Failed to parse Gemini response, using fallback:', parseError.message);
        analysis = {
          summary: {
            investment_quote: 'ÊäïËµÑÈúÄË∞®ÊÖéÔºåÂÖ≥Ê≥®ÊîøÁ≠ñÂØºÂêë',
            core_logic: `‰ªäÊó•ÂÖ±${newsItems.length}Êù°Êñ∞ÈóªÔºå‰∏ªË¶ÅÊ∂âÂèäÁªèÊµé„ÄÅÁßëÊäÄ„ÄÅÁ§æ‰ºöÁ≠âÂ§ö‰∏™È¢ÜÂüü„ÄÇ`
          },
          opportunity_analysis: []
        };
      }
      
      // Ensure all fields are present with defaults
      analysis.summary = analysis.summary || {
        investment_quote: 'ÊäïËµÑÈúÄË∞®ÊÖéÔºåÂÖ≥Ê≥®ÊîøÁ≠ñÂØºÂêë',
        core_logic: `‰ªäÊó•ÂÖ±${newsItems.length}Êù°Êñ∞ÈóªÔºå‰∏ªË¶ÅÊ∂âÂèäÁªèÊµé„ÄÅÁßëÊäÄ„ÄÅÁ§æ‰ºöÁ≠âÂ§ö‰∏™È¢ÜÂüü„ÄÇ`
      };
      analysis.opportunity_analysis = analysis.opportunity_analysis || [];
      
      console.log('Parsed analysis:', analysis);

      const result = {
        summary: analysis.summary,
        total_news: newsItems.length,
        opportunity_analysis: analysis.opportunity_analysis,
        has_data: true,
        ...(fallbackDate ? { fallback_from: fallbackDate } : {})
      };

      // Save analysis with timestamp
      const timestamp = getBeijingTime().format('YYYYMMDD_HHmmss');
      const analysisWithMeta = {
        ...result,
        generated_at: timestamp,
        news_date: fallbackDate || today
      };
      const actualAnalysisFile = path.join(this.analysisDir, `${fallbackDate || today}.json`);
      await fs.writeJson(actualAnalysisFile, analysisWithMeta);
      console.log(`üíæ Saved analysis to ${actualAnalysisFile}`);

      return result;
      
    } catch (error) {
      console.warn(`‚ö†Ô∏è Could not generate AI summary for today (${today}.json):`, error.message);
      return {
        summary: {
          investment_quote: 'ÊäïËµÑÈúÄË∞®ÊÖéÔºåÂÖ≥Ê≥®ÊîøÁ≠ñÂØºÂêë',
          core_logic: '‰ªäÊó•Êñ∞ÈóªÊï∞ÊçÆÊöÇÊú™Êõ¥Êñ∞ÊàñAIÂàÜÊûêÊúçÂä°‰∏çÂèØÁî®'
        },
        total_news: '--',
        opportunity_analysis: [],
        has_data: false
      };
    }
  }

  // Generate fallback summary when AI is not available
  generateFallbackSummary(newsItems) {
    // Extract categories and count them
    const categoryCount = {};
    newsItems.forEach(news => {
      if (news.news_hl_tag) {
        const categories = news.news_hl_tag.split(/[,\s]+/).filter(cat => cat.trim());
        categories.forEach(cat => {
          const cleanCat = cat.trim();
          if (cleanCat && cleanCat !== 'General') {
            categoryCount[cleanCat] = (categoryCount[cleanCat] || 0) + 1;
          }
        });
      }
    });
    
    // Get top categories
    const topCategories = Object.entries(categoryCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([cat, count]) => `${cat}(${count}Êù°)`);
    
    const summaryText = topCategories.length > 0 ? 
      `‰ªäÊó•ÂÖ±${newsItems.length}Êù°Êñ∞ÈóªÔºå‰∏ªË¶ÅÊ∂âÂèä${topCategories.join('„ÄÅ')}Á≠âÈ¢ÜÂüü„ÄÇ` :
      `‰ªäÊó•ÂÖ±${newsItems.length}Êù°Êñ∞ÈóªÔºåÊ∂µÁõñÂ§ö‰∏™ÈáçË¶ÅÈ¢ÜÂüü„ÄÇ`;

    return {
      summary: {
        investment_quote: 'ÊäïËµÑÈúÄË∞®ÊÖéÔºåÂÖ≥Ê≥®ÊîøÁ≠ñÂØºÂêë',
        core_logic: summaryText
      },
      total_news: newsItems.length,
      opportunity_analysis: [],
      has_data: true
    };
  }

  async generateHomePage(index) {
    console.log('üè† Generating home page...');

    // Generate AI-powered daily summary
    const dailySummary = await this.generateDailySummary();

    const html = `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trend Following AI - ‰Ω†ÁöÑË∂ãÂäøÊäïËµÑAIÂä©Êâã</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header>
        <div class="container">
            <a href="/" class="site-title">trendfollowing.ai</a>
            <nav class="nav-menu">
                <a href="/" class="nav-link active">CCTV Trend</a>
                <!-- <a href="#" class="nav-link">Product 2</a> -->
                <!-- <a href="#" class="nav-link">Product 3</a> -->
            </nav>
        </div>
    </header>

    <main class="container">
        <!-- Introduction Section -->
        <section class="intro-section">
            <h1 style="font-size: 2.8rem; font-weight: 700; color: #1a202c; text-align: center; margin: 0 0 1.5rem 0; line-height: 1.1;">Êñ∞ÈóªËÅîÊí≠ÊäïËµÑÂàÜÊûê</h1>
            <p style="font-size: 1.2rem; color: #4a5568; text-align: center; margin: 0; line-height: 1.6; max-width: 650px; margin: 0 auto; font-weight: 400;">
                ÂÆûÊó∂Ëß£Á†ÅÊñ∞ÈóªËÅîÊí≠ÔºåAIËØÜÂà´Ë∂ãÂäøÊäïËµÑÊú∫‰ºö„ÄÇ
            </p>
        </section>

        <!-- Trend Insights Section -->
        <section>
            <h2>Ë∂ãÂäøÊ¥ûÂØü</h2>
            <div class="analysis-summary">
                <div class="daily-quote-card">
                    <h3>‰ªäÊó•ËßÇÁÇπ</h3>
                    <p> ${dailySummary.summary?.investment_quote || 'ÊäïËµÑÈúÄË∞®ÊÖéÔºåÂÖ≥Ê≥®ÊîøÁ≠ñÂØºÂêëË∂ãÂäø'} </p>
                    <div class="meta-info">
                        <button class="btn-copy read-more" onclick="copyQuote()" title="Â§çÂà∂ÈáëÂè•">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <circle cx="18" cy="5" r="3"></circle>
                                <circle cx="6" cy="12" r="3"></circle>
                                <circle cx="18" cy="19" r="3"></circle>
                                <path d="m8.5 14 7-7"></path>
                                <path d="m8.5 10 7 7"></path>
                            </svg>
                            ÂàÜ‰∫´
                        </button>
                    </div>
                </div>
                <div class="core-logic-card">
                    <h3>Ê†∏ÂøÉÈÄªËæë</h3>
                    <p>${dailySummary.summary?.core_logic || '‰ªäÊó•Êñ∞ÈóªÊï∞ÊçÆÊöÇÊú™Êõ¥Êñ∞'}</p>
                    <div class="meta-info" style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
                        <span class="update-time">Êõ¥Êñ∞Êó∂Èó¥: ${dailySummary.has_data ? new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' }) : 'ÊöÇÊó†Êï∞ÊçÆ'}</span>
                        ${dailySummary.fallback_from ? `<span class="fallback-notice" style="color: #f59e0b; font-size: 0.8rem;">Âü∫‰∫é${moment(dailySummary.fallback_from, 'YYYYMMDD').format('MM-DD')}ÂàÜÊûê</span>` : ''}
                        <a href="/archive/${moment(dailySummary.fallback_from || moment().format('YYYYMMDD'), 'YYYYMMDD').format('YYYY')}/${dailySummary.fallback_from || moment().format('YYYYMMDD')}.html" class="news-count read-more">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <polyline points="14,2 14,8 20,8"></polyline>
                                <line x1="16" y1="13" x2="8" y2="13"></line>
                                <line x1="16" y1="17" x2="8" y2="17"></line>
                                <polyline points="10,9 9,9 8,9"></polyline>
                            </svg>
                            ${dailySummary.total_news || 0} Êù°Êñ∞Èóª
                        </a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Investment Opportunities Section -->
        ${dailySummary.opportunity_analysis?.length > 0 ? `
        <section>
            <h2>ÊäïËµÑÊú∫‰ºö</h2>
            <div class="cards-grid">
                ${dailySummary.opportunity_analysis.map((opportunity, index) => `
                    <div class="opportunity-card">
                        ${opportunity.related_news_ids?.length > 0 ? 
                            `<h4><a href="/archive/${moment(dailySummary.fallback_from || moment().format('YYYYMMDD'), 'YYYYMMDD').format('YYYY')}/${dailySummary.fallback_from || moment().format('YYYYMMDD')}.html#${opportunity.related_news_ids[0]}" style="color: inherit; text-decoration: none;">${opportunity.theme}</a></h4>` :
                            `<h4>${opportunity.theme}</h4>`
                        }
                        ${opportunity.core_stocks?.length > 0 ? `
                        <div class="stocks-section">
                            <h5>Ê†∏ÂøÉÊ†áÁöÑÔºö</h5>
                            <div class="stocks-list">
                                ${opportunity.core_stocks.map(stock => `<button class="stock-tag" onclick="copyToClipboard('${stock}', this)">${stock}</button>`).join('')}
                            </div>
                        </div>
                        ` : ''}
                        ${opportunity.sector_etfs?.length > 0 ? `
                        <div class="etfs-section">
                            <h5>Ë°å‰∏öETFÔºö</h5>
                            <div class="etfs-list">
                                ${opportunity.sector_etfs.map(etf => `<button class="etf-tag" onclick="copyToClipboard('${etf}', this)">${etf}</button>`).join('')}
                            </div>
                        </div>
                        ` : ''}
                        <div class="actionable-advice-section">
                            <span class="actionable-advice">${opportunity.actionable_advice}</span>
                        </div>
                    </div>
                `).join('')}
            </div>
        </section>
        ` : ''}

        <!-- Latest News Section - Hidden for now
        <section>
            <h2>ÊúÄÊñ∞Êñ∞Èóª</h2>
            <div class="news-grid">
                ${index.recentNews.slice(0, 6).map(news => `
                    <div class="news-card">
                        <a href="/archive/${news.year}/${news.date}.html#${news.video_id}" class="news-title-link">
                            <h4>${this.cleanTitle(news.video_title)}</h4>
                        </a>
                        <div class="news-meta">
                            <span>${moment(news.date, 'YYYYMMDD').format('YYYY-MM-DD')}</span>
                        </div>
                        <p class="news-brief">${this.truncateSummary(this.extractSummaryFromContent(news.video_detail?.content), 100)}...</p>
                        <a href="/archive/${news.year}/${news.date}.html#${news.video_id}" class="read-more">ÈòÖËØªÊõ¥Â§ö</a>
                    </div>
                `).join('')}
            </div>
        </section>
        -->

        <!-- Search News Section - Hidden for now
        <section class="search-section">
            <h2>ÊêúÁ¥¢Êñ∞Èóª</h2>
            <div class="search-container">
                <input type="text" id="searchInput" placeholder="ËæìÂÖ•ÂÖ≥ÈîÆËØçÊêúÁ¥¢...">
            </div>
            <div class="filter-controls">
                <select id="yearFilter">
                    <option value="">ÈÄâÊã©Âπ¥‰ªΩ</option>
                    ${Object.keys(index.years).sort().reverse().map(year => `<option value="${year}">${year}Âπ¥</option>`).join('')}
                </select>
                <select id="monthFilter" disabled>
                    <option value="">ÈÄâÊã©Êúà‰ªΩ</option>
                    ${Array.from({length: 12}, (_, i) => {
                      const month = (i + 1).toString().padStart(2, '0');
                      return `<option value="${month}">${month}Êúà</option>`;
                    }).join('')}
                </select>
                <select id="dateFilter" disabled>
                    <option value="">ÈÄâÊã©Êó•Êúü</option>
                    ${Array.from({length: 31}, (_, i) => {
                      const date = (i + 1).toString().padStart(2, '0');
                      return `<option value="${date}">${date}Êó•</option>`;
                    }).join('')}
                </select>
                <select id="categoryFilter">
                    <option value="">ÊâÄÊúâÂàÜÁ±ª</option>
                    ${Object.keys(index.categories).sort().map(cat => `<option value="${cat}">${cat}</option>`).join('')}
                </select>
            </div>
            <div id="searchResults"></div>
        </section>
        -->

        <!-- <section>
            <h2>ÊåâÂπ¥‰ªΩÊµèËßà</h2>
            <div class="archive-nav">
                ${Object.entries(index.years).sort().reverse().map(([year, data]) => `
                    <a href="/archive/${year}/" class="year-link">${year}Âπ¥</a>
                `).join('')}
            </div>
        </section> -->
    </main>

    <footer>
        <div class="container">
            <p>Êï∞ÊçÆÊù•Ê∫êÔºöCCTV ÂÆòÁΩë | ‰ªÖ‰æõÂ≠¶‰π†‰ΩøÁî®</p>
        </div>
    </footer>

    <script src="/js/main.js"></script>
</body>
</html>`;
    
    await fs.writeFile(path.join(this.outputDir, 'index.html'), html);
  }

  async generateArchivePages(index) {
    const limitText = this.daysLimit ? `past ${this.daysLimit} days` : 'all available data';
    console.log(`üìÑ Generating archive pages (${limitText})...`);
    
    // Calculate cutoff date if daysLimit is set
    const cutoffDate = this.daysLimit ? moment().subtract(this.daysLimit, 'days').format('YYYYMMDD') : null;
    
    // Generate year index pages (only for years that have recent data if limited)
    for (const [year, yearData] of Object.entries(index.years)) {
      // Check if this year has any days within the limit
      let hasData = false;
      for (const [month, days] of Object.entries(yearData.months)) {
        for (const day of days) {
          if (!cutoffDate || day.date >= cutoffDate) {
            hasData = true;
            break;
          }
        }
        if (hasData) break;
      }
      
      if (!hasData) continue;
      
      await fs.ensureDir(path.join(this.outputDir, 'archive', year));
      
      // Year index page (filtered if daysLimit is set)
      const filteredYearData = {
        months: {},
        totalNews: 0
      };
      
      for (const [month, days] of Object.entries(yearData.months)) {
        const filteredDays = cutoffDate ? days.filter(day => day.date >= cutoffDate) : days;
        if (filteredDays.length > 0) {
          filteredYearData.months[month] = filteredDays;
          filteredYearData.totalNews += filteredDays.reduce((sum, day) => sum + day.newsCount, 0);
        }
      }
      
      const yearHtml = this.generateYearPage(year, filteredYearData);
      await fs.writeFile(path.join(this.outputDir, 'archive', year, 'index.html'), yearHtml);
      
      // Individual day pages (filtered if daysLimit is set)
      for (const [month, days] of Object.entries(yearData.months)) {
        for (const day of days) {
          if (!cutoffDate || day.date >= cutoffDate) {
            const dayHtml = await this.generateDayPage(day);
            await fs.writeFile(path.join(this.outputDir, 'archive', year, `${day.date}.html`), dayHtml);
          }
        }
      }
    }
  }

  generateYearPage(year, yearData) {
    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${year}Âπ¥Êñ∞ÈóªÂΩíÊ°£ - CCTV Êñ∞ÈóªËÅîÊí≠</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header>
        <div class="container">
            <a href="/" class="site-title">trendfollowing.ai</a>
            <nav class="nav-menu">
                <a href="/" class="nav-link active">CCTV Trend</a>
                <!-- <a href="#" class="nav-link">Product 2</a> -->
                <!-- <a href="#" class="nav-link">Product 3</a> -->
            </nav>
        </div>
    </header>

    <main class="container">
        <h1>${year}Âπ¥</h1>
        <p style="text-align: center; margin-bottom: 3rem; color: #64748b;">
            ÂÖ± ${yearData.totalNews} Êù°Êñ∞Èóª
        </p>

        <div class="news-grid">
            ${Object.entries(yearData.months).map(([month, days]) => `
                <div class="news-card">
                    <h3>${parseInt(month)}Êúà</h3>
                    <div style="margin-top: 1rem;">
                        ${days.map(day => `
                            <a href="${day.date}.html" style="display: block; padding: 0.5rem 0; color: var(--accent-color); text-decoration: none; border-bottom: 1px solid var(--border-color);">
                                ${day.date.substring(6, 8)}Êó• (${day.newsCount}Êù°)
                            </a>
                        `).join('')}
                    </div>
                </div>
            `).join('')}
        </div>
    </main>

    <footer>
        <div class="container">
            <p>Êï∞ÊçÆÊù•Ê∫êÔºöCCTV ÂÆòÁΩë | ‰ªÖ‰æõÂ≠¶‰π†‰ΩøÁî®</p>
        </div>
    </footer>

    <script src="/js/main.js"></script>
</body>
</html>`;
  }

  async generateDayPage(dayInfo) {
    const filePath = path.join(this.assetsDir, dayInfo.file);
    const data = await fs.readJson(filePath);
    
    return `
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${moment(dayInfo.date, 'YYYYMMDD').format('YYYYÂπ¥MMÊúàDDÊó•')}Êñ∞Èóª - CCTV Êñ∞ÈóªËÅîÊí≠</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <header>
        <div class="container">
            <a href="/" class="site-title">trendfollowing.ai</a>
            <nav class="nav-menu">
                <a href="/" class="nav-link active">CCTV Trend</a>
                <!-- <a href="#" class="nav-link">Product 2</a> -->
                <!-- <a href="#" class="nav-link">Product 3</a> -->
            </nav>
        </div>
    </header>

    <main class="container">
        <h1>${moment(dayInfo.date, 'YYYYMMDD').format('YYYYÂπ¥MMÊúàDDÊó•')}</h1>
        <p style="text-align: center; margin-bottom: 3rem; color: #64748b;">
            ÂÖ± ${data.videoList.length} Êù°Êñ∞Èóª
        </p>

        <div class="news-list">
            ${data.videoList.map(video => `
                <article class="news-item">
                    <h2 id="${video.video_id}">${this.cleanTitle(video.video_title)}</h2>
                    <div class="news-meta" style="flex-direction: row; flex-wrap: wrap; gap: 1rem;">
                        <span>‚è∞ ${video.video_length}</span>
                        <span>üè∑Ô∏è ${video.news_hl_tag || 'General'}</span>
                        <span>üìÖ ${video.pub_date}</span>
                    </div>
                    ${video.video_image ? `<img src="${video.video_image}" alt="${video.video_title}" class="news-image" style="max-width: 100%; height: auto; border-radius: 0.5rem; margin: 1rem 0;">` : ''}
                    <p class="news-brief">${video.brief || ''}</p>
                    ${video.video_detail && video.video_detail.content ? `
                        <div class="news-content" style="margin-top: 1.5rem; padding-top: 1.5rem; border-top: 1px solid var(--border-color);">
                            ${video.video_detail.content}
                        </div>
                    ` : ''}
                    <div class="news-actions" style="margin-top: 2rem;">
                        <a href="${video.video_url}" target="_blank" class="btn-primary">ËßÇÁúãËßÜÈ¢ë</a>
                        <a href="/" class="btn-secondary">ËøîÂõû‰∏ªÈ°µ</a>
                        <button onclick="shareNews('${video.video_title}', '${video.video_url}')" class="btn-secondary">ÂàÜ‰∫´</button>
                    </div>
                </article>
            `).join('')}
        </div>
    </main>

    <footer>
        <div class="container">
            <p>Êï∞ÊçÆÊù•Ê∫êÔºöCCTV ÂÆòÁΩë | ‰ªÖ‰æõÂ≠¶‰π†‰ΩøÁî®</p>
        </div>
    </footer>

    <script src="/js/main.js"></script>
</body>
</html>`;
  }

  async generateAPIEndpoints(index) {
    console.log('üîå Generating API endpoints...');
    
    // Create API directory
    await fs.ensureDir(path.join(this.outputDir, 'api'));
    
    // Main index API
    await fs.writeJson(path.join(this.outputDir, 'api', 'index.json'), index);
    
    // Recent news API
    await fs.writeJson(path.join(this.outputDir, 'api', 'recent.json'), {
      news: index.recentNews.slice(0, 50)
    });
    
    // Search index for client-side search
    const limitText = this.daysLimit ? `past ${this.daysLimit} days` : 'all available data';
    console.log(`üìä Generating search index (${limitText})...`);
    
    const searchIndex = [];
    const cutoffDate = this.daysLimit ? moment().subtract(this.daysLimit, 'days').format('YYYYMMDD') : null;
    
    for (const [year, yearData] of Object.entries(index.years)) {
      for (const [month, days] of Object.entries(yearData.months)) {
        for (const day of days) {
          if (!cutoffDate || day.date >= cutoffDate) {
            const filePath = path.join(this.assetsDir, day.file);
            try {
              const data = await fs.readJson(filePath);
              data.videoList.forEach(video => {
                searchIndex.push({
                  id: video.video_id,
                  title: this.cleanTitle(video.video_title),
                  brief: (video.brief || '').substring(0, 200), // Limit brief length
                  category: video.news_hl_tag || '',
                  date: day.date,
                  year: year,
                  month: day.date.substring(4, 6),
                  day: day.date.substring(6, 8),
                  url: `/archive/${year}/${day.date}.html#${video.video_id}`
                });
              });
            } catch (error) {
              console.warn(`‚ö†Ô∏è  Error reading ${filePath} for search index`);
            }
          }
        }
      }
    }
    
    console.log(`üìä Generated search index with ${searchIndex.length} items`);
    await fs.writeJson(path.join(this.outputDir, 'api', 'search.json'), { index: searchIndex });
  }
}

// Run the build
if (require.main === module) {
  const forceApi = process.argv.includes('--force-api');
  
  // Parse days limit from command line (default to 7, use null for no limit)
  let daysLimit = 7; // Default to 7 days
  const daysArg = process.argv.find(arg => arg.startsWith('--days='));
  if (daysArg) {
    const daysValue = daysArg.split('=')[1];
    daysLimit = daysValue === 'all' ? null : parseInt(daysValue);
  }
  
  const builder = new NewsArchiveBuilder({ forceApi, daysLimit });
  const limitText = daysLimit ? `${daysLimit} days` : 'all data';
  console.log(`üèóÔ∏è Building in ${forceApi ? 'FORCE API' : 'SMART CACHE'} mode (limiting to ${limitText})`);
  builder.build().catch(console.error);
}

module.exports = NewsArchiveBuilder;